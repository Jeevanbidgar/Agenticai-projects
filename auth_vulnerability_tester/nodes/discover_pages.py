from __future__ import annotations

from pathlib import Path
from loguru import logger
from utils.state import TestState, StepResult
from detectors.auth_detector import detect_auth_paths
from utils.browser_helpers import navigate_and_wait, to_absolute_url
from utils.evidence import capture_step


async def discover_pages(state: TestState) -> TestState:
    logger.info("[discover_pages] Discovering login/signup URLs")
    run_dir = Path(state.runtime["run_dir"]) 
    paths = detect_auth_paths(state.url, state.domain_config)
    state.selectors_resolved["login_candidates"] = paths.get("login_candidates", [])
    state.selectors_resolved["signup_candidates"] = paths.get("signup_candidates", [])

    page = state.runtime.get("page")
    if page:
        # Always visit landing URL first
        try:
            logger.info(f"[discover_pages] Navigating to landing URL: {state.url}")
            await navigate_and_wait(page, state.url, timeout_ms=state.runtime.get("timeout", 30) * 1000)
            await capture_step(page, run_dir, "00_landing_page", state.runtime.get("viewport_only", False), state)
        except Exception:
            pass

        # Quick inline auth form detection on landing page (including commonly used auth widgets)
        try:
            # Allow SPA hydration before scanning
            try:
                await page.wait_for_timeout(800)
            except Exception:
                pass
            email_candidates = [
                "input[type='email']",
                "input[name*='email' i]",
                "#email",
                "[autocomplete='email']",
                "#identifier",
            ]
            pw_candidates = [
                "input[type='password']",
                "input[name*='password' i]",
                "#password",
                "[autocomplete='new-password']",
                "[autocomplete='current-password']",
            ]
            submit_candidates = [
                "button[type='submit']",
                "input[type='submit']",
                "button:has-text('Sign up')",
                "button:has-text('Sign in')",
                "button:has-text('Log in')",
                "button:has-text('Start Learning')",
                "button:has-text('Continue')",
                "[data-testid='password-button']",
            ]
            # If fields are within an iframe, try to detect the active iframe
            iframes = page.frames
            search_page = page
            for fr in iframes:
                try:
                    # Heuristic: iframe that contains a password field
                    if await fr.locator("input[type='password']").count() > 0:
                        search_page = fr
                        break
                except Exception:
                    continue
            # prefer iframe search_page if it contains auth fields, else fallback to page
            inline_email = next((sel for sel in email_candidates if (await search_page.locator(sel).count()) > 0), None)
            inline_pw = next((sel for sel in pw_candidates if (await search_page.locator(sel).count()) > 0), None)
            inline_submit = next((sel for sel in submit_candidates if (await search_page.locator(sel).count()) > 0), None)
            if not (inline_email and inline_pw and inline_submit):
                inline_email = next((sel for sel in email_candidates if (await page.locator(sel).count()) > 0), None)
                inline_pw = next((sel for sel in pw_candidates if (await page.locator(sel).count()) > 0), None)
                inline_submit = next((sel for sel in submit_candidates if (await page.locator(sel).count()) > 0), None)
            if inline_email and inline_pw and inline_submit:
                logger.info(f"[discover_pages] Inline form detected email={inline_email} password={inline_pw} submit={inline_submit}")
                state.selectors_resolved["inline_form"] = {
                    "email": inline_email,
                    "password": inline_pw,
                    "submit": inline_submit,
                }
                # Prefer current URL as candidate for both flows
                for key in ("login_candidates", "signup_candidates"):
                    lst = state.selectors_resolved.get(key, [])
                    if state.url not in lst:
                        state.selectors_resolved[key] = [state.url] + lst
            else:
                # One more short re-scan after UI settles
                try:
                    await page.wait_for_timeout(800)
                except Exception:
                    pass
                inline_email = next((sel for sel in email_candidates if (await page.locator(sel).count()) > 0), None)
                inline_pw = next((sel for sel in pw_candidates if (await page.locator(sel).count()) > 0), None)
                inline_submit = next((sel for sel in submit_candidates if (await page.locator(sel).count()) > 0), None)
                if inline_email and inline_pw and inline_submit:
                    logger.info(f"[discover_pages] Inline form detected on re-scan email={inline_email} password={inline_pw} submit={inline_submit}")
                    state.selectors_resolved["inline_form"] = {
                        "email": inline_email,
                        "password": inline_pw,
                        "submit": inline_submit,
                    }
                    for key in ("login_candidates", "signup_candidates"):
                        lst = state.selectors_resolved.get(key, [])
                        if state.url not in lst:
                            state.selectors_resolved[key] = [state.url] + lst
        except Exception:
            pass

        # If inline form was found on landing page, do not navigate away
        inline = state.selectors_resolved.get("inline_form")
        if not inline:
            # Try navigating to discovered pages to verify (sample a couple)
            candidates = (
                state.selectors_resolved.get("login_candidates", [])
                + state.selectors_resolved.get("signup_candidates", [])
            )
            for idx, url in enumerate(candidates[:2]):  # sample first two
                try:
                    abs_url = to_absolute_url(state.url, url)
                    logger.info(f"[discover_pages] Probing candidate[{idx}]: {abs_url}")
                    await navigate_and_wait(page, abs_url, timeout_ms=state.runtime.get("timeout", 30) * 1000)
                    await capture_step(page, run_dir, f"01_discover_pages_{idx}", state.runtime.get("viewport_only", False), state)
                except Exception:
                    continue

    state.steps.append(StepResult(name="discover_pages", status="ok", message="Candidates prepared"))
    return state


