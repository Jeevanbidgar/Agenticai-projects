from __future__ import annotations

from pathlib import Path
from loguru import logger
from utils.state import TestState, StepResult
from utils.browser_helpers import wait_for_navigation, save_storage_snapshot, expect_and_handle_oauth_popup, capture_performance_metrics, extract_account_identifier, extract_identifier_fallbacks
from utils.evidence import capture_step
from utils.human_behavior import human_delay


async def google_sso_register(state: TestState) -> TestState:
    logger.info("[google_sso_register] Google SSO registration")
    run_dir = Path(state.runtime["run_dir"]) 
    page = state.runtime.get("page")
    sso_ok = False
    try:
        if page and state.sso_options:
            logger.info("[google_sso_register] Preparing to click Google SSO")
            await capture_step(page, run_dir, "06_sso_before", state.runtime.get("viewport_only", False), state)
            selector = state.sso_options[0].selector
            logger.info(f"[google_sso_register] Clicking selector: {selector}")
            # Snapshot baseline
            try:
                await save_storage_snapshot(page, "pre_sso", state.storage_artifacts)
            except Exception:
                pass
            # Determine target domain for return detection
            try:
                from utils.config_loader import registered_domain_from_url
                target_domain = registered_domain_from_url(state.url)
            except Exception:
                target_domain = None
            opened = await expect_and_handle_oauth_popup(
                page,
                selector,
                state.test_email,
                state.oauth_redirects,
                target_domain,
            )
            logger.info(f"[google_sso_register] OAuth flow triggered: {opened}")
            # Give popup time to render and bot checks to settle
            await human_delay(0.5, 1.0)
            if opened:
                # Wait for any navigation or SPA idle after OAuth completes
                try:
                    await wait_for_navigation(page, timeout_ms=state.runtime.get("timeout", 30) * 1000)
                except Exception:
                    pass
                await capture_step(page, run_dir, "06_sso_after", state.runtime.get("viewport_only", False), state)
                await save_storage_snapshot(page, "after_sso", state.storage_artifacts)
                # Attempt to extract account identifier post-SSO
                ident_sel = state.domain_config.get("account_identifier")
                ident = None
                # Poll briefly for post-SSO session/identifier
                try:
                    from utils.config_loader import registered_domain_from_url
                    target_domain = registered_domain_from_url(state.url)
                except Exception:
                    target_domain = None
                for _ in range(10):  # ~5s total
                    try:
                        ident = await extract_account_identifier(page, ident_sel)
                        if not ident:
                            ident = await extract_identifier_fallbacks(page)
                        if ident:
                            break
                        # Check domain and cookies as alternative success signal
                        url_ok = target_domain and (target_domain in (page.url or ""))
                        if url_ok:
                            break
                    except Exception:
                        pass
                    await human_delay(0.3, 0.6)
                if ident:
                    state.selectors_resolved["identifier_after_sso"] = ident
                state.timings["google_sso_register"] = await capture_performance_metrics(page)
                # Consider SSO successful if identifier present or we returned to target domain
                try:
                    url_ok = target_domain and (target_domain in (page.url or ""))
                except Exception:
                    url_ok = False
                sso_ok = bool(ident or url_ok)
    except Exception as e:
        logger.debug(f"google_sso_register error: {e}")
    state.sso_result = {"status": "ok" if sso_ok else "inconclusive", "url": getattr(page, "url", None)}
    state.steps.append(StepResult(name="google_sso_register", status="ok" if sso_ok else "inconclusive", message=f"sso_ok={sso_ok}"))
    return state


