from __future__ import annotations

from pathlib import Path
from loguru import logger
from utils.state import TestState, StepResult
from core.email_handler import MailSlurpHandler
from utils.browser_helpers import navigate_and_wait, save_storage_snapshot
from utils.evidence import capture_step
from utils.gmail_helper import click_latest_verification_link
from utils.human_behavior import human_delay


async def email_verification(state: TestState) -> TestState:
    logger.info("[email_verification] Email verification")
    run_dir = Path(state.runtime["run_dir"]) 
    page = state.runtime.get("page")
    email_verified = False
    inbox_id = state.mailslurp_inbox_id
    ms = MailSlurpHandler()
    try:
        if not inbox_id and (not state.test_email or state.test_email.endswith("@mailslurp.com")):
            inbox = ms.create_inbox()
            if inbox:
                inbox_id = inbox["id"]
                state.mailslurp_inbox_id = inbox_id
                state.test_email = inbox["emailAddress"]
        if inbox_id:
            email = ms.wait_for_latest_email(inbox_id, timeout_seconds=state.domain_config.get("timeouts", {}).get("email_verification_seconds", 120), poll_interval=5)
            if email:
                link = ms.extract_first_link(email)
                if link and page:
                    await capture_step(page, run_dir, "05_email_verification_before", state.runtime.get("viewport_only", False), state)
                    await human_delay(0.3, 0.6)
                    await navigate_and_wait(page, link, timeout_ms=state.runtime.get("timeout", 30) * 1000)
                    await capture_step(page, run_dir, "05_email_verification_after", state.runtime.get("viewport_only", False), state)
                    await save_storage_snapshot(page, "after_verification", state.storage_artifacts)
                    email_verified = True
            elif state.test_email and state.test_email.endswith("@gmail.com") and page:
                # Gmail-based verification fallback (if MailSlurp not used)
                ctx = page.context
                if await click_latest_verification_link(ctx, timeout_seconds=state.domain_config.get("timeouts", {}).get("email_verification_seconds", 120)):
                    email_verified = True
    except Exception as e:
        logger.debug(f"email_verification error: {e}")
    state.verification_required = not email_verified
    state.steps.append(StepResult(name="email_verification", status="ok" if email_verified else "inconclusive", message=f"verified={email_verified}"))
    return state


