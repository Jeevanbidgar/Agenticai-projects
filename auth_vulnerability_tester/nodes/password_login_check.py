from __future__ import annotations

from pathlib import Path
from loguru import logger
from utils.state import TestState, StepResult
from utils.browser_helpers import navigate_and_wait, fill_form_field, save_storage_snapshot, extract_account_identifier, capture_performance_metrics, to_absolute_url, smart_submit
from utils.evidence import capture_step
from core.browser_manager import BrowserManager
from utils.human_behavior import human_delay


async def password_login_check(state: TestState) -> TestState:
    logger.info("[password_login_check] Password login check")
    run_dir = Path(state.runtime["run_dir"]) 
    sso_cfg = state.domain_config
    bm: BrowserManager = state.runtime.get("bm")
    if bm:
        # Use fresh context to simulate attacker
        context = await bm.new_target_context(har_path=None)
        # Hygiene: best-effort clear cache and service workers
        try:
            sw = await context.service_workers()
            for w in sw:
                try:
                    await w.evaluate("() => self.registration.unregister()")
                except Exception:
                    pass
        except Exception:
            pass
        page = await context.new_page()
        try:
            inline = state.selectors_resolved.get("inline_form")
            login_url = sso_cfg.get("login_url") or (state.selectors_resolved.get("login_candidates") or [None])[0]
            if login_url:
                abs_url = to_absolute_url(state.url, login_url)
                if not (inline and login_url == state.url):
                    logger.info(f"[password_login_check] Navigating to login URL: {abs_url}")
                    await navigate_and_wait(page, abs_url, timeout_ms=state.runtime.get("timeout", 30) * 1000)
                await capture_step(page, run_dir, "08_login_before", state.runtime.get("viewport_only", False), state)
                # Let SPA validators bind and fields render fully
                await human_delay(0.3, 0.6)
                # Prefer inline selectors if discovered, else config, else heuristics
                email_sel = (inline or {}).get("email") or sso_cfg.get("email_field") or "#identifier, input[type='email'], input[name*='email' i]"
                pw_sel = (inline or {}).get("password") or sso_cfg.get("password_field") or "#password, input[type='password']"
                submit_sel = (inline or {}).get("submit") or sso_cfg.get("submit_button") or "button[data-testid='password-button'], button[type='submit'], input[type='submit']"
                logger.info(f"[password_login_check] Filling fields email={email_sel} password={pw_sel}")
                ok1 = await fill_form_field(page, email_sel, state.test_email or "") if email_sel else False
                ok2 = await fill_form_field(page, pw_sel, state.test_password or "") if pw_sel else False
                attempted = False
                if submit_sel:
                    await human_delay(0.2, 0.5)
                    try:
                        logger.info(f"[password_login_check] Clicking submit: {submit_sel}")
                        await page.locator(submit_sel).first.click()
                        attempted = True
                    except Exception:
                        attempted = False
                if not attempted:
                    logger.info("[password_login_check] Fallback smart_submit")
                    await smart_submit(page, submit_sel)
                await navigate_and_wait(page, page.url, timeout_ms=state.runtime.get("timeout", 30) * 1000)
                await capture_step(page, run_dir, "08_login_after", state.runtime.get("viewport_only", False), state)
                await save_storage_snapshot(page, "after_login", state.storage_artifacts)
                state.timings["password_login_check"] = await capture_performance_metrics(page)
                ident_sel = sso_cfg.get("account_identifier")
                ident = await extract_account_identifier(page, ident_sel)
                state.account_identifier = ident
                state.password_login_result = {"ok": bool(ok1 and ok2 and ident)}
        except Exception as e:
            logger.debug(f"password_login_check error: {e}")
        finally:
            await context.close()
    state.steps.append(StepResult(name="password_login_check", status="ok" if state.password_login_result.get("ok") else "inconclusive", message=str(state.password_login_result)))
    return state


