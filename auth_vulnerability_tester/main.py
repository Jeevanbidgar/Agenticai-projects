import os
import sys
import json
import asyncio
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional, List

import click
from urllib.parse import urlparse
from dotenv import load_dotenv
from loguru import logger
import tldextract

from utils.logger import configure_logging
from utils.config_loader import load_config_for_domain
from utils.state import TestState, StepResult
from utils.evidence import attach_network_logging, validate_evidence
from utils.cache import load_cached_selectors, save_cached_selectors

# LangGraph
from langgraph.graph import StateGraph
from core.workflow import build_async_workflow, run_workflow


def ensure_results_dir(base_output_dir: str, url: str) -> Path:
    extracted = tldextract.extract(url)
    domain = ".".join([part for part in [extracted.domain, extracted.suffix] if part]) or extracted.registered_domain
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d_%H-%M-%S")
    run_dir = Path(base_output_dir) / f"{timestamp}_{domain}"
    (run_dir / "screenshots").mkdir(parents=True, exist_ok=True)
    return run_dir


def consent_notice(granted: bool):
    if granted:
        return
    logger.warning(
        "You must have explicit permission to test this target. Use --i-have-permission to suppress this notice."
    )


def resolve_email(cli_email: Optional[str]) -> str:
    env_email = os.getenv("GOOGLE_TEST_EMAIL")
    if cli_email:
        return cli_email
    if env_email:
        return env_email
    return ""


def resolve_password(cli_password: Optional[str]) -> str:
    # Site password must NOT default to GOOGLE_TEST_PASSWORD.
    # Use CLI --password or TARGET_PASSWORD from environment.
    if cli_password:
        return cli_password
    env_target = os.getenv("TARGET_PASSWORD")
    return env_target or ""


def build_graph():
    from nodes.discover_pages import discover_pages
    from nodes.dismiss_cookies import dismiss_cookies
    from nodes.detect_sso_buttons import detect_sso_buttons
    from nodes.password_signup import password_signup
    from nodes.email_verification import email_verification
    from nodes.google_sso_register import google_sso_register
    from nodes.password_login_check import password_login_check
    from nodes.analyze_vulnerability import analyze_vulnerability
    from nodes.report_results import report_results

    graph = StateGraph(TestState)
    graph.add_node("discover_pages", discover_pages)
    graph.add_node("dismiss_cookies", dismiss_cookies)
    graph.add_node("detect_sso_buttons", detect_sso_buttons)
    graph.add_node("password_signup", password_signup)
    graph.add_node("email_verification", email_verification)
    graph.add_node("google_sso_register", google_sso_register)
    graph.add_node("password_login_check", password_login_check)
    graph.add_node("analyze_vulnerability", analyze_vulnerability)
    graph.add_node("report_results", report_results)

    graph.set_entry_point("discover_pages")
    graph.add_edge("discover_pages", "dismiss_cookies")
    graph.add_edge("dismiss_cookies", "detect_sso_buttons")
    graph.add_edge("detect_sso_buttons", "password_signup")
    graph.add_edge("password_signup", "email_verification")
    graph.add_edge("email_verification", "google_sso_register")
    graph.add_edge("google_sso_register", "password_login_check")
    graph.add_edge("password_login_check", "analyze_vulnerability")
    graph.add_edge("analyze_vulnerability", "report_results")

    return graph.compile()


def _preflight_validate_site_config(state: TestState) -> list[str]:
    required_keys = ["email_field", "password_field", "submit_button", "account_identifier"]
    missing = [k for k in required_keys if not state.domain_config.get(k)]
    if missing:
        logger.warning(f"Preflight: Missing site config keys: {missing}")
        state.steps.append(
            StepResult(
                name="preflight_validation",
                status="inconclusive",
                message=f"Missing keys: {', '.join(missing)}",
            )
        )
    else:
        state.steps.append(
            StepResult(
                name="preflight_validation",
                status="ok",
                message="Selectors present in site config",
            )
        )
    return missing

@click.command()
@click.option("--url", required=True, help="Target base URL to test")
@click.option("--email", default=None, help="Test email; defaults to GOOGLE_TEST_EMAIL if unset")
@click.option("--password", default=None, help="Test password for password-based signup/login")
@click.option("--config", "config_path", default="config/default.yaml", show_default=True)
@click.option("--headless/--headed", default=False, show_default=True, help="Browser mode (headed by default)")
@click.option("--providers", default="google", show_default=True, help="Comma-separated SSO providers to test")
@click.option("--timeout", default=30, show_default=True, help="Per-step timeout in seconds")
@click.option("--slowmo", default=None, type=int, help="Override slowMo (ms) for debugging vs speed runs")
@click.option("--output-dir", default="./results", show_default=True, help="Output directory for results")
@click.option("--save-har", is_flag=True, default=False, help="Save HAR network trace")
@click.option("--viewport-only", is_flag=True, default=False, help="Viewport-only screenshots instead of full-page")
@click.option("--clear-google-cache", is_flag=True, default=False, help="Clear cached Google profile before run")
@click.option("--allow-email-mismatch", is_flag=True, default=False, help="Suppress mismatch warning when --email != GOOGLE_TEST_EMAIL")
@click.option("--skip-password-check-if-unverified", is_flag=True, default=False)
@click.option("--auto-install", is_flag=True, default=False, help="Auto-install Playwright browsers if missing")
@click.option("--redact-pii", is_flag=True, default=False, help="Redact PII in reports")
@click.option("--proxy", default=None, help="Proxy URL (http/https/socks5)")
@click.option("--i-have-permission", is_flag=True, default=False, help="Confirm you have authorization to test")
@click.option("--resume-from", "resume_from", default=None, help="Resume workflow from a node name")
@click.option("--fail-on-preflight", is_flag=True, default=False, help="Fail fast if required site selectors are missing")
def cli(
    url: str,
    email: Optional[str],
    password: Optional[str],
    config_path: str,
    headless: bool,
    providers: str,
    timeout: int,
    slowmo: Optional[int],
    output_dir: str,
    save_har: bool,
    viewport_only: bool,
    clear_google_cache: bool,
    allow_email_mismatch: bool,
    skip_password_check_if_unverified: bool,
    auto_install: bool,
    redact_pii: bool,
    proxy: Optional[str],
    i_have_permission: bool,
    resume_from: Optional[str],
    fail_on_preflight: bool,
):
    # Load .env and environment
    load_dotenv(override=False)

    # Prepare run directory and logging
    run_dir = ensure_results_dir(output_dir, url)
    configure_logging(run_dir)
    consent_notice(i_have_permission)

    # Effective email/password
    effective_email = resolve_email(email)
    effective_password = resolve_password(password)
    google_pw = os.getenv("GOOGLE_TEST_PASSWORD", "")

    # Email alignment validation
    env_google_email = os.getenv("GOOGLE_TEST_EMAIL")
    if effective_email and env_google_email and effective_email != env_google_email and not allow_email_mismatch:
        logger.warning("--email differs from GOOGLE_TEST_EMAIL. This may cause false negatives.")
        logger.warning("Use --allow-email-mismatch to suppress this warning.")

    # Password alignment warning (site vs Google)
    if effective_password and google_pw and effective_password == google_pw:
        logger.warning("Site password matches GOOGLE_TEST_PASSWORD. This reduces test integrity.")
        logger.warning("Pass a different --password to simulate attacker-controlled credentials.")

    # Ensure we have a site password (no auto-generation)
    if not effective_password:
        logger.error("No site password provided. Set --password or TARGET_PASSWORD in .env")
        # Write minimal reports and exit to avoid half-baked run
        from reporters.json_reporter import write_json_report
        from reporters.markdown_reporter import write_markdown_summary
        state = TestState(
            url=url,
            domain_config={},
            test_email=effective_email,
            test_password=effective_password,
            browser_page=None,
            selectors_resolved={},
            steps=[StepResult(name="preflight_validation", status="inconclusive", message="Missing site password")],
            evidence_paths=[],
            errors=[],
            verification_required=False,
            sso_options=[],
            account_identifier=None,
            storage_artifacts={},
            timings={},
            vulnerability_found=False,
            vulnerability_details=None,
            runtime={"run_dir": str(run_dir)},
        )
        write_json_report(state, Path(run_dir) / "report.json")
        write_markdown_summary(state, Path(run_dir) / "summary.md")
        sys.exit(2)

    # Load configuration with domain-specific overrides
    domain_config = load_config_for_domain(url, config_path)

    # Providers list
    providers_list = [p.strip() for p in providers.split(",") if p.strip()]

    # Initialize state (browser not launched in Phase 1 skeleton)
    state = TestState(
        url=url,
        domain_config=domain_config,
        test_email=effective_email,
        test_password=effective_password,
        browser_page=None,
        selectors_resolved={},
        steps=[],
        evidence_paths=[],
        errors=[],
        verification_required=False,
        sso_options=[],
        account_identifier=None,
        storage_artifacts={},
        timings={},
        vulnerability_found=False,
        vulnerability_details=None,
        runtime={
            "providers": providers_list,
            "timeout": timeout,
            "save_har": save_har,
            "viewport_only": viewport_only,
            "clear_google_cache": clear_google_cache,
            "skip_password_check_if_unverified": skip_password_check_if_unverified,
            "auto_install": auto_install,
            "redact_pii": redact_pii,
            "proxy": proxy,
            "run_dir": str(run_dir),
            "resume_from": resume_from,
        },
    )

    # Preflight site config validation
    missing = _preflight_validate_site_config(state)
    if fail_on_preflight and missing:
        logger.error("Preflight failed and --fail-on-preflight is set. Exiting.")
        from reporters.json_reporter import write_json_report
        from reporters.markdown_reporter import write_markdown_summary
        write_json_report(state, Path(state.runtime["run_dir"]) / "report.json")
        write_markdown_summary(state, Path(state.runtime["run_dir"]) / "summary.md")
        sys.exit(2)

    # Execute async workflow with BrowserManager managing Playwright lifetime
    try:
        from core.browser_manager import BrowserManager
        from core.email_handler import MailSlurpHandler
        browser_cfg = domain_config.get("browser", {})
        proxy_url = state.runtime.get("proxy")
        if proxy_url:
            valid_schemes = ["http", "https", "socks5"]
            parsed = urlparse(proxy_url)
            if parsed.scheme not in valid_schemes:
                raise ValueError(f"Proxy scheme must be one of: {valid_schemes}")

        bm = BrowserManager(
            headless=headless is True,
            slow_mo_ms=slowmo if slowmo is not None else browser_cfg.get("slow_mo_ms", 300),
            locale=browser_cfg.get("locale", "en-US"),
            timezone=browser_cfg.get("timezone", "UTC"),
            google_profile_path=browser_cfg.get("google_profile_path", "./.cache/google_profile"),
            viewport_size_choices=tuple(browser_cfg.get("viewport_width", [1200, 1400, 1600])),
            viewport_height_choices=tuple(browser_cfg.get("viewport_height", [800, 900, 1000])),
            user_agents=list(browser_cfg.get("user_agents", [])),
            proxy=state.runtime.get("proxy"),
            save_har=state.runtime.get("save_har", False),
            default_timeout_ms=browser_cfg.get("default_timeout", 30000),
            channel_preference=browser_cfg.get("channel", "chrome"),
            use_google_window_for_target=True,
        )

        async def _run():
            # Auto-install if requested
            if state.runtime.get("auto_install"):
                try:
                    from playwright.async_api import async_playwright as _ap
                    _p = await _ap().start()
                    _b = await _p.chromium.launch(headless=True)
                    await _b.close()
                    await _p.stop()
                except Exception:
                    logger.info("Installing Playwright browsers...")
                    os.system("playwright install chromium")
            async with bm:
                state.runtime["bm"] = bm
                await bm.ensure_google_session(
                    email=state.test_email,
                    password=google_pw,
                    clear_cache=state.runtime.get("clear_google_cache", False),
                    run_dir=Path(state.runtime["run_dir"]),
                )
                # If we launched a new browser, open Gmail inbox tab to finalize bootstrap
                try:
                    await bm.open_gmail_inbox_if_new_browser()
                except Exception:
                    pass
                har_path = Path(state.runtime["run_dir"]) / "network_trace.har" if state.runtime.get("save_har") else None
                context = await bm.new_target_context(har_path=har_path)
                page = await context.new_page()
                state.runtime["context"] = context
                state.runtime["page"] = page
                await bm.attach_console_logging(page, Path(state.runtime["run_dir"]) / "console.log")
                # Seed Google session into target context if not attached to existing Chrome
                try:
                    if not getattr(bm, "connected_existing_chrome", False):
                        await bm.ensure_google_session_in_context(context, state.test_email, google_pw)
                except Exception:
                    pass
                # Attach network logging when HAR is disabled
                if not state.runtime.get("save_har"):
                    await attach_network_logging(page, Path(state.runtime["run_dir"]) / "evidence" / "network.jsonl", state.runtime.get("redact_pii", False))

                # Prepare MailSlurp inbox if email not provided
                if not state.test_email:
                    ms = MailSlurpHandler()
                    try:
                        inbox = ms.create_inbox()
                        if inbox:
                            state.mailslurp_inbox_id = inbox["id"]
                            state.test_email = inbox["emailAddress"]
                    except Exception as e:
                        logger.warning(f"MailSlurp inbox creation failed: {e}")

                from core.workflow import run_workflow as _wf
                # Load cached selectors for this domain and merge into state
                try:
                    project_root = Path(__file__).resolve().parent
                    cached = load_cached_selectors(project_root, state.url)
                    if cached:
                        state.selectors_resolved.update(cached)
                except Exception:
                    pass
                return await _wf(state)

        import asyncio as _asyncio
        result_state = _asyncio.run(_run())
    except Exception as exc:
        logger.warning(f"Browser setup/workflow encountered an issue (continuing): {exc}")
        import asyncio as _asyncio
        result_state = _asyncio.run(run_workflow(state))

    # Generate reports via ReportGenerator
    try:
        from reporters.report_generator import ReportGenerator
        templates_dir = Path(__file__).resolve().parent / "reporters" / "templates"
        rg = ReportGenerator(templates_dir)
        rg.write_json(result_state, Path(state.runtime["run_dir"]) / "report.json")
        rg.write_markdown(result_state, Path(state.runtime["run_dir"]) / "summary.md")
    except Exception:
        # Fallback to legacy reporters if generator not available
        from reporters.json_reporter import write_json_report
        from reporters.markdown_reporter import write_markdown_summary
        write_json_report(result_state, Path(state.runtime["run_dir"]) / "report.json")
        write_markdown_summary(result_state, Path(state.runtime["run_dir"]) / "summary.md")
    # Evidence validation summary (not failing the run)
    try:
        browser_cfg = domain_config.get("browser", {})
        viewport = {"width": browser_cfg.get("viewport_width", [1200])[0], "height": browser_cfg.get("viewport_height", [800])[0]}
        validation = validate_evidence(Path(state.runtime["run_dir"]), viewport)
        Path(state.runtime["run_dir"]) / "evidence"
        (Path(state.runtime["run_dir"]) / "evidence").mkdir(exist_ok=True, parents=True)
        (Path(state.runtime["run_dir"]) / "evidence" / "validation.json").write_text(json.dumps(validation, indent=2), encoding="utf-8")
    except Exception:
        pass

    # Persist learned selectors for next runs
    try:
        project_root = Path(__file__).resolve().parent
        learned = {}
        if state.selectors_resolved.get("inline_form"):
            learned["inline_form"] = state.selectors_resolved["inline_form"]
        if state.selectors_resolved.get("sso_catalog"):
            learned["sso_catalog"] = state.selectors_resolved["sso_catalog"]
        if learned:
            save_cached_selectors(project_root, state.url, learned)
    except Exception:
        pass

    logger.info(f"Run complete. Results at {state.runtime['run_dir']}")


if __name__ == "__main__":
    cli()


