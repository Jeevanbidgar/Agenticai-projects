from __future__ import annotations

import os
import random
from pathlib import Path
from typing import Optional, Tuple
import requests

from loguru import logger
from playwright.async_api import async_playwright, Playwright, Browser, BrowserContext, Page


class BrowserManager:
    """Playwright lifecycle manager with persistent Google session and target contexts.

    - Launches a persistent Google profile context without proxy
    - Launches a separate browser for target-site contexts (proxy optional)
    - Applies anti-bot defaults (locale, timezone, slowMo, UA, viewport, flags)
    - Provides validation helper and console logging
    """

    def __init__(
        self,
        headless: bool,
        slow_mo_ms: int,
        locale: str,
        timezone: str,
        google_profile_path: str,
        viewport_size_choices: Tuple[int, int, int] | Tuple[int, int] | None = None,
        viewport_height_choices: Tuple[int, int, int] | Tuple[int, int] | None = None,
        user_agents: Optional[list[str]] = None,
        proxy: Optional[str] = None,
        save_har: bool = False,
        default_timeout_ms: int = 30000,
        channel_preference: str = "chrome",
        try_connect_running: bool = True,
            use_google_window_for_target: bool = True,
    ) -> None:
        self.headless = headless
        self.slow_mo_ms = slow_mo_ms
        self.locale = locale
        self.timezone = timezone
        self.google_profile_path = google_profile_path
        self.proxy = proxy
        self.save_har = save_har
        self.default_timeout_ms = default_timeout_ms
        self.channel_preference = channel_preference
        self.try_connect_running = try_connect_running
        self.use_google_window_for_target = use_google_window_for_target

        # Randomized but consistent per run
        self.user_agents = user_agents or []
        self.viewport_widths = list(viewport_size_choices) if viewport_size_choices else [1366, 1440, 1600]
        self.viewport_heights = list(viewport_height_choices) if viewport_height_choices else [768, 900, 1000]
        self.run_user_agent = random.choice(self.user_agents) if self.user_agents else None
        self.run_viewport = {
            "width": random.choice(self.viewport_widths),
            "height": random.choice(self.viewport_heights),
        }

        # Runtime handles
        self._pw: Optional[Playwright] = None
        self.google_context: Optional[BrowserContext] = None
        self.target_browser: Optional[Browser] = None
        self.connected_existing_chrome: bool = False

        Path(self.google_profile_path).mkdir(parents=True, exist_ok=True)

    async def __aenter__(self):
        self._pw = await async_playwright().start()

        launch_args = ["--disable-blink-features=AutomationControlled"]

        # First: try to connect to an already running Chrome via CDP
        connected = False
        if self.try_connect_running:
            for port in (9222, 9223):
                # Try HTTP endpoint first
                try:
                    self.target_browser = await self._pw.chromium.connect_over_cdp(f"http://127.0.0.1:{port}")
                    self.connected_existing_chrome = True
                    connected = True
                    logger.info(f"Connected to existing Chrome via CDP at 127.0.0.1:{port}; will open new tab for operations")
                    break
                except Exception as exc:
                    logger.debug(f"CDP HTTP connect failed on {port}: {exc}")
                # Fallback: fetch WS endpoint explicitly
                try:
                    resp = requests.get(f"http://127.0.0.1:{port}/json/version", timeout=0.5)
                    if resp.ok:
                        ws_url = resp.json().get("webSocketDebuggerUrl")
                        if ws_url:
                            self.target_browser = await self._pw.chromium.connect_over_cdp(ws_url)
                            self.connected_existing_chrome = True
                            connected = True
                            logger.info(f"Connected to existing Chrome via WS CDP at 127.0.0.1:{port}")
                            break
                except Exception as exc:
                    logger.debug(f"CDP WS connect failed on {port}: {exc}")

        # If connected to an existing Chrome, reuse its context as Google context
        if connected and self.target_browser:
            if self.target_browser.contexts:
                self.google_context = self.target_browser.contexts[0]
            else:
                page = await self.target_browser.new_page()
                self.google_context = page.context
            self.google_context.set_default_timeout(self.default_timeout_ms)
        else:
            # Launch Google persistent context (no proxy)
            try:
                self.google_context = await self._pw.chromium.launch_persistent_context(
                    user_data_dir=self.google_profile_path,
                    channel=self.channel_preference,
                    headless=self.headless,
                    slow_mo=self.slow_mo_ms,
                    args=launch_args,
                    locale=self.locale,
                    timezone_id=self.timezone,
                )
            except Exception:
                logger.warning("System Chrome not found, using bundled Chromium")
                self.google_context = await self._pw.chromium.launch_persistent_context(
                    user_data_dir=self.google_profile_path,
                    headless=self.headless,
                    slow_mo=self.slow_mo_ms,
                    args=launch_args,
                    locale=self.locale,
                    timezone_id=self.timezone,
                )
            self.google_context.set_default_timeout(self.default_timeout_ms)

        # Launch target browser (proxy optional) if not connected
        if not connected:
            try:
                self.target_browser = await self._pw.chromium.launch(
                    channel=self.channel_preference,
                    headless=self.headless,
                    slow_mo=self.slow_mo_ms,
                    args=launch_args,
                    proxy={"server": self.proxy} if self.proxy else None,
                )
            except Exception:
                logger.warning("System Chrome not found (target), using bundled Chromium")
                self.target_browser = await self._pw.chromium.launch(
                    headless=self.headless,
                    slow_mo=self.slow_mo_ms,
                    args=launch_args,
                    proxy={"server": self.proxy} if self.proxy else None,
                )

        return self

    async def __aexit__(self, exc_type, exc, tb):
        try:
            if self.google_context:
                await self.google_context.close()
        finally:
            try:
                if self.target_browser and not self.connected_existing_chrome:
                    await self.target_browser.close()
            finally:
                if self._pw:
                    await self._pw.stop()

    async def new_target_context(self, har_path: Optional[Path] = None) -> BrowserContext:
        if not self.target_browser:
            raise RuntimeError("Target browser is not launched")
        if self.connected_existing_chrome:
            # In CDP attached mode, use the default persistent context
            if self.target_browser.contexts:
                context = self.target_browser.contexts[0]
            else:
                # Create a tab to materialize context
                page = await self.target_browser.new_page()
                context = page.context
            logger.info("Using existing Chrome context; HAR capture not available in attached mode")
        else:
            # If configured, open target in the same persistent Google window to avoid multi-window issues
            if self.use_google_window_for_target and self.google_context is not None:
                logger.info("Using Google persistent context for target tabs (same window)")
                return self.google_context
            kwargs = dict(
                locale=self.locale,
                timezone_id=self.timezone,
                user_agent=self.run_user_agent,
                viewport=self.run_viewport,
            )
            if har_path:
                # Try newer API first (record_har_path), then older style (record_har={"path": ...})
                try:
                    context = await self.target_browser.new_context(
                        **kwargs,
                        record_har_path=str(har_path),
                    )
                except TypeError:
                    try:
                        context = await self.target_browser.new_context(
                            **kwargs,
                            record_har={"path": str(har_path)},
                        )
                    except TypeError:
                        logger.warning("HAR recording not supported by this Playwright version; continuing without HAR")
                        context = await self.target_browser.new_context(**kwargs)
            else:
                context = await self.target_browser.new_context(**kwargs)
        context.set_default_timeout(self.default_timeout_ms)
        return context

    async def attach_console_logging(self, page: Page, console_log_path: Path) -> None:
        console_log_path.parent.mkdir(parents=True, exist_ok=True)
        if not console_log_path.exists():
            console_log_path.write_text("", encoding="utf-8")

        async def _on_console(msg):
            try:
                line = getattr(msg, "text", None)
                if callable(line):
                    line = line()
                if line is None:
                    line = str(msg)
                with console_log_path.open("a", encoding="utf-8") as f:
                    f.write(line + "\n")
            except Exception:
                pass

        page.on("console", _on_console)

    async def ensure_google_session_in_context(self, context: BrowserContext, email: Optional[str], password: Optional[str]) -> None:
        """Seed Google session inside the target context so OAuth popups are already authenticated.

        This is used when we are NOT attached to an existing Chrome with a logged-in profile.
        """
        try:
            page = await context.new_page()
            await page.goto("https://accounts.google.com/", wait_until="domcontentloaded")
            html = await page.content()
            if ("Sign in" in html or "identifierId" in html) and email and password:
                await page.fill("#identifierId, input[type=email]", email)
                await page.click("#identifierNext, button:has-text('Next')")
                await page.wait_for_timeout(500)
                await page.fill("input[type=password]", password)
                await page.click("#passwordNext, button:has-text('Next')")
                try:
                    await page.wait_for_load_state("domcontentloaded", timeout=5000)
                except Exception:
                    pass
            await page.close()
        except Exception:
            # Non-blocking; continue without seeded session
            pass

    async def ensure_google_session(
        self,
        email: Optional[str],
        password: Optional[str],
        clear_cache: bool,
        run_dir: Path,
    ) -> None:
        if not self.google_context:
            raise RuntimeError("Google persistent context not available")

        if clear_cache and os.path.isdir(self.google_profile_path):
            # Best-effort clear: Playwright requires context closed before deleting; caller should ensure fresh instance if needed.
            logger.info("Clearing Google profile cache as requested")
            # Do not delete here to avoid OS locks; document via CLI to delete before run in future phases.

        # Always use a transient tab to validate session; close it afterward to avoid blocking UI
        page = await self.google_context.new_page()
        created_tab = True
        await page.goto("https://accounts.google.com/", wait_until="domcontentloaded")
        content = await page.content()
        if "Sign in" not in content and "identifierId" not in content:
            logger.info("Google session appears valid (no sign-in prompt)")
            # Still attempt to dismiss any post-login recovery prompts
            await self._maybe_skip_phone_recovery(page)
            try:
                if created_tab:
                    await page.close()
            except Exception:
                pass
            return

        if not email or not password:
            logger.warning("GOOGLE_TEST_EMAIL/GOOGLE_TEST_PASSWORD missing; cannot auto-login. Proceeding without manual prompt; continuing with existing session if any.")
            return

        try:
            # Email step
            await page.fill("#identifierId, input[type=email]", email)
            await page.click("#identifierNext, button:has-text('Next')")
            await page.wait_for_timeout(800)
            # Password step
            await page.fill("input[type=password]", password)
            await page.click("#passwordNext, button:has-text('Next')")
            # Do not block on networkidle; give it a brief moment then continue
            try:
                await page.wait_for_load_state("domcontentloaded", timeout=min(5000, self.default_timeout_ms))
            except Exception:
                pass
            await self._maybe_skip_phone_recovery(page)
            try:
                if created_tab:
                    await page.close()
            except Exception:
                pass
        except Exception:
            logger.warning("Google may require manual verification; proceeding without blocking. Continuing workflow with current session state.")
            try:
                if created_tab:
                    await page.close()
            except Exception:
                pass

    async def test_browser_setup(self, run_dir: Path, viewport_only: bool = False) -> None:
        """Navigate to httpbin and capture a validation screenshot; check JS execution."""
        context = await self.new_target_context()
        page = await context.new_page()
        await page.goto("https://httpbin.org/user-agent", wait_until="domcontentloaded")
        # Screenshot
        shot_path = run_dir / "screenshots" / "00_browser_validation.png"
        await page.screenshot(path=str(shot_path), full_page=not viewport_only)
        # JS capability check
        ua = await page.evaluate("() => navigator.userAgent")
        tz = await page.evaluate("() => Intl.DateTimeFormat().resolvedOptions().timeZone")
        logger.info(f"Browser validation: UA={ua[:60]}..., TZ={tz}")
        await context.close()


    async def _maybe_skip_phone_recovery(self, page: Page) -> None:
        """Best-effort skip for phone recovery or similar interstitials."""
        try:
            # Common labels Google uses
            selectors = [
                "button:has-text('Skip')",
                "a:has-text('Skip')",
                "button:has-text('Not now')",
                "a:has-text('Not now')",
                "#phoneSkip, #skip, #exp-ckd-phone-skip",
            ]
            for sel in selectors:
                try:
                    loc = page.locator(sel)
                    if await loc.count() > 0 and await loc.first.is_visible():
                        await loc.first.click()
                        await page.wait_for_load_state("networkidle", timeout=self.default_timeout_ms)
                        break
                except Exception:
                    continue
        except Exception:
            pass

    async def open_gmail_inbox_if_new_browser(self) -> None:
        """If we launched our own browser (no existing Chrome attached), open Gmail inbox in a new tab."""
        if self.connected_existing_chrome:
            return
        if not self.google_context:
            return
        page = await self.google_context.new_page()
        await page.goto("https://mail.google.com/mail/u/0/#inbox", wait_until="domcontentloaded")
        # Let it settle briefly
        await page.wait_for_load_state("networkidle")


