from __future__ import annotations

import asyncio
from typing import Callable, Dict

from loguru import logger
from langgraph.graph import StateGraph

from utils.state import TestState
from utils.exceptions import BrowserSetupError, GoogleAuthError, TargetSiteError
from core.state_manager import save_checkpoint, validate_state_transition


def build_async_workflow():
    """Keep a LangGraph topology defined (for visualization/compatibility), but execution
    is driven by run_workflow below to support rich conditional routing and retries.
    """
    from nodes.discover_pages import discover_pages
    from nodes.dismiss_cookies import dismiss_cookies
    from nodes.detect_sso_buttons import detect_sso_buttons
    from nodes.password_signup import password_signup
    from nodes.email_verification import email_verification
    from nodes.google_sso_register import google_sso_register
    from nodes.password_login_check import password_login_check
    from nodes.analyze_vulnerability import analyze_vulnerability
    from nodes.report_results import report_results

    graph = StateGraph(TestState)
    graph.add_node("discover_pages", discover_pages)
    graph.add_node("dismiss_cookies", dismiss_cookies)
    graph.add_node("detect_sso_buttons", detect_sso_buttons)
    graph.add_node("password_signup", password_signup)
    graph.add_node("email_verification", email_verification)
    graph.add_node("google_sso_register", google_sso_register)
    graph.add_node("password_login_check", password_login_check)
    graph.add_node("analyze_vulnerability", analyze_vulnerability)
    graph.add_node("report_results", report_results)

    graph.set_entry_point("discover_pages")
    graph.add_edge("discover_pages", "dismiss_cookies")
    graph.add_edge("dismiss_cookies", "detect_sso_buttons")
    graph.add_edge("detect_sso_buttons", "password_signup")
    graph.add_edge("password_signup", "email_verification")
    graph.add_edge("email_verification", "google_sso_register")
    graph.add_edge("google_sso_register", "password_login_check")
    graph.add_edge("password_login_check", "analyze_vulnerability")
    graph.add_edge("analyze_vulnerability", "report_results")

    return graph.compile()


async def run_workflow(state: TestState) -> TestState:
    """Execute nodes sequentially with conditional routing, retries, and checkpoints."""
    from nodes.discover_pages import discover_pages
    from nodes.dismiss_cookies import dismiss_cookies
    from nodes.detect_sso_buttons import detect_sso_buttons
    from nodes.password_signup import password_signup
    from nodes.email_verification import email_verification
    from nodes.google_sso_register import google_sso_register
    from nodes.password_login_check import password_login_check
    from nodes.analyze_vulnerability import analyze_vulnerability
    from nodes.report_results import report_results

    node_funcs: Dict[str, Callable[[TestState], TestState]] = {
        "discover_pages": discover_pages,
        "dismiss_cookies": dismiss_cookies,
        "detect_sso_buttons": detect_sso_buttons,
        "password_signup": password_signup,
        "email_verification": email_verification,
        "google_sso_register": google_sso_register,
        "password_login_check": password_login_check,
        "analyze_vulnerability": analyze_vulnerability,
        "report_results": report_results,
    }

    sequence = [
        "discover_pages",
        "dismiss_cookies",
        "detect_sso_buttons",
        "password_signup",
        "email_verification",
        "google_sso_register",
        "password_login_check",
        "analyze_vulnerability",
        "report_results",
    ]

    resume_from = state.runtime.get("resume_from")
    skipping = bool(resume_from)

    async def run_node(node_name: str):
        nonlocal state
        # Resume gating
        nonlocal skipping
        if skipping:
            if node_name == resume_from:
                skipping = False
            else:
                logger.info(f"Skipping {node_name} due to resume gating")
                return

        fn = node_funcs[node_name]
        try:
                # Validate prerequisites
            validate_state_transition(state, node_name)
        except Exception as e:
                # Mark step as inconclusive and stop further processing for this node
                from utils.state import StepResult
                state.steps.append(StepResult(name=f"validate:{node_name}", status="inconclusive", message=str(e)))
                save_checkpoint(state, node_name)
                return
        # Retries/backoff
        for attempt in range(3):
            try:
                state = await fn(state)  # type: ignore[func-returns-value]
                save_checkpoint(state, node_name)
                return
            except (TargetSiteError, GoogleAuthError) as e:
                # Mark inconclusive and continue
                logger.warning(f"{node_name} encountered recoverable error: {e}")
                save_checkpoint(state, node_name)
                return
            except Exception as e:
                if attempt == 2:
                    logger.error(f"{node_name} failed after retries: {e}")
                    save_checkpoint(state, node_name)
                    return
                await asyncio.sleep(1 * (2 ** attempt))

    idx = 0
    while idx < len(sequence):
        node = sequence[idx]
        await run_node(node)

        # Conditional routing
        if node == "password_signup":
            if state.runtime.get("skip_password_check_if_unverified") and state.verification_required:
                # Skip to analysis after SSO
                idx = sequence.index("email_verification")  # next step executes; email node will mark/skip
        if node == "email_verification":
            # Always continue to SSO
            pass
        if node == "google_sso_register":
            # Proceed to password_login_check regardless, per spec
            # Allow backend propagation before attacker check
            try:
                import asyncio as _a
                await _a.sleep(2)
            except Exception:
                pass
        idx += 1

    return state


