from __future__ import annotations

import os
import re
import time
from typing import Optional

from loguru import logger

try:
    import mailslurp_client
    from mailslurp_client import ApiClient
    from mailslurp_client.apis.tags import inbox_controller_api, email_controller_api
except Exception:
    mailslurp_client = None
    ApiClient = None
    inbox_controller_api = None
    email_controller_api = None


class MailSlurpHandler:
    """MailSlurp integration: create inbox, poll for verification emails, extract links."""

    def __init__(self, api_key: Optional[str] = None) -> None:
        self.api_key = api_key or os.getenv("MAILSLURP_API_KEY")
        if not self.api_key:
            logger.warning("MAILSLURP_API_KEY not set. Email verification may be inconclusive.")
        self.client: Optional[ApiClient] = None

    def _ensure_client(self):
        if mailslurp_client is None:
            raise RuntimeError("mailslurp-client package not installed")
        if not self.client:
            config = mailslurp_client.Configuration()
            config.api_key["x-api-key"] = self.api_key
            self.client = ApiClient(config)

    def create_inbox(self) -> Optional[dict]:
        self._ensure_client()
        api = inbox_controller_api.InboxControllerApi(self.client)
        inbox = api.create_inbox()
        logger.info(f"Created MailSlurp inbox: {inbox.id}")
        return {"id": str(inbox.id), "emailAddress": inbox.email_address}

    def wait_for_latest_email(self, inbox_id: str, timeout_seconds: int = 120, poll_interval: int = 5):
        self._ensure_client()
        api = email_controller_api.EmailControllerApi(self.client)
        start = time.time()
        last_exception = None
        while time.time() - start < timeout_seconds:
            try:
                emails = api.get_emails_paginated(inbox_id=inbox_id, page=0, size=1, sort="DESC").content
                if emails:
                    email_id = emails[0].id
                    email = api.get_email(email_id)
                    return email
            except Exception as exc:  # keep polling
                last_exception = exc
            time.sleep(poll_interval)
        if last_exception:
            logger.debug(f"MailSlurp polling ended with last error: {last_exception}")
        return None

    @staticmethod
    def extract_first_link(email) -> Optional[str]:
        bodies = []
        if getattr(email, "body", None):
            bodies.append(email.body)
        if getattr(email, "body_md", None):
            bodies.append(email.body_md)
        if getattr(email, "body_html", None):
            bodies.append(email.body_html)
        pattern = re.compile(r"https?://\S+")
        for body in bodies:
            if not body:
                continue
            m = pattern.search(body)
            if m:
                return m.group(0).rstrip(').,;\'"')
        return None


