from __future__ import annotations

import json
from pathlib import Path
from typing import Optional

from loguru import logger

from utils.state import TestState
from utils.exceptions import StateValidationError


def _checkpoint_dir(run_dir: Path) -> Path:
    d = run_dir / "checkpoints"
    d.mkdir(parents=True, exist_ok=True)
    return d


def save_checkpoint(state: TestState, node_name: str) -> None:
    path = _checkpoint_dir(Path(state.runtime["run_dir"])) / f"{node_name}.json"
    path.write_text(json.dumps(state.to_dict(), indent=2), encoding="utf-8")


def load_checkpoint(run_dir: Path, node_name: str) -> Optional[TestState]:
    path = _checkpoint_dir(run_dir) / f"{node_name}.json"
    if not path.exists():
        return None
    data = json.loads(path.read_text(encoding="utf-8"))
    return TestState.from_dict(data)


def resume_from_failure(run_dir: Path) -> Optional[str]:
    d = _checkpoint_dir(run_dir)
    # return the last checkpoint by lexicographic order (nodes are numbered in names in future phases)
    candidates = sorted(p.stem for p in d.glob("*.json"))
    return candidates[-1] if candidates else None


def validate_state_transition(state: TestState, next_node: str) -> None:
    if next_node == "google_sso_register":
        if not state.sso_options:
            raise StateValidationError("google_sso_register requires sso_options")
    if next_node == "password_login_check":
        if not (state.test_email and state.test_password):
            raise StateValidationError("password_login_check requires test_email and test_password")
    if next_node == "analyze_vulnerability":
        if not (isinstance(state.password_login_result, dict) and isinstance(state.sso_result, dict)):
            raise StateValidationError("analyze_vulnerability requires password_login_result and sso_result")


