from __future__ import annotations

import json
from pathlib import Path
from typing import Any, Dict, List

from jinja2 import Environment, FileSystemLoader, select_autoescape

from utils.state import TestState


def _jinja_env(templates_dir: Path) -> Environment:
    return Environment(
        loader=FileSystemLoader(str(templates_dir)),
        autoescape=select_autoescape(["html", "xml", "md"]),
        trim_blocks=True,
        lstrip_blocks=True,
    )


class ReportGenerator:
    def __init__(self, templates_dir: Path) -> None:
        self.templates_dir = templates_dir
        self.env = _jinja_env(templates_dir) if templates_dir.exists() else None

    def write_markdown(self, state: TestState, out_path: Path) -> None:
        default_template = """
# Account Takeover Pre-Auth Test Report

- Target: {{ state.url }}

- Email: {{ state.test_email or 'N/A' }}

- Vulnerability Found: {{ state.vulnerability_found }}

{% if state.vulnerability_details %}- Details: {{ state.vulnerability_details }}

{% endif %}## Evidence Timeline

| Index | Artifact |
|-------|----------|
{% for path in state.evidence_paths %}| {{ loop.index }} | ![evidence]({{ path }}){width=600} |
{% endfor %}

## Steps

{% for step in state.steps %}- {{ step.name }}: {{ step.status }} - {{ step.message or '' }}
{% endfor %}

## Remediation Guidance

{% for item in remediation %}- {{ item }}
{% endfor %}
        """
        try:
            if self.env:
                tmpl = self.env.get_template("summary.md.j2")
                md = tmpl.render(state=state, remediation=self._remediation(state), schema_version="v1")
            else:
                md = Environment().from_string(default_template).render(
                    state=state, remediation=self._remediation(state), schema_version="v1"
                )
            if not md or not md.strip():
                raise RuntimeError("empty markdown")
            out_path.write_text(md, encoding="utf-8")
        except Exception:
            minimal = "Summary\n\n" + "\n".join(
                f"- {s.name}: {s.status}" for s in (state.steps or [])
            )
            out_path.write_text(minimal, encoding="utf-8")

    def write_json(self, state: TestState, out_path: Path) -> None:
        payload: Dict[str, Any] = {
            "report_schema": "v1",
            "metadata": {
                "url": state.url,
                "test_email": state.test_email,
            },
            "steps": [s.model_dump() for s in state.steps],
            "evidence": state.evidence_paths,
            "storage_snapshots": state.storage_artifacts,
            "oauth_redirects": state.oauth_redirects,
            "network_log_summary": self._network_summary(Path(state.runtime.get("run_dir", "."))),
            "vulnerability_scoring": {
                "rubric": state.vulnerability_details or "",
                "cvss_like": self._cvss_like(state),
            },
            "remediation": self._remediation(state),
        }
        out_path.write_text(json.dumps(payload, indent=2), encoding="utf-8")

    def _cvss_like(self, state: TestState) -> Dict[str, Any]:
        # Simplified mapping from rubric text
        sev = "NONE"
        score = 0.0
        vector = "AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:N"
        details = (state.vulnerability_details or "").lower()
        if "severity: high" in details or "high" in details:
            sev, score, vector = "HIGH", 8.8, "AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N"
        elif "severity: medium" in details or "medium" in details:
            sev, score, vector = "MEDIUM", 6.5, "AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N"
        elif "severity: low" in details or "low" in details:
            sev, score, vector = "LOW", 3.1, "AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N"
        return {"severity": sev, "score": score, "vector": vector}

    def _remediation(self, state: TestState) -> List[str]:
        return [
            "Verify email ownership before allowing SSO account linking",
            "Reject or quarantine pre-registered accounts when SSO registers the same email",
            "Implement explicit account linking flows requiring identity confirmation",
            "Harden session binding and ensure password login is invalidated after SSO linkage",
        ]

    def _network_summary(self, run_dir: Path) -> Dict[str, Any]:
        path = run_dir / "evidence" / "network.jsonl"
        if not path.exists():
            return {"exists": False, "lines": 0}
        try:
            lines = sum(1 for _ in path.open("r", encoding="utf-8"))
            return {"exists": True, "lines": lines, "path": str(path)}
        except Exception:
            return {"exists": True, "lines": 0, "path": str(path)}


