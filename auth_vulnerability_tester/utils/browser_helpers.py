from __future__ import annotations

import asyncio
import random
from pathlib import Path
from urllib.parse import urljoin
from typing import List, Optional, Tuple

from loguru import logger
from playwright.async_api import Page, TimeoutError as PlaywrightTimeoutError, Locator

from utils.selectors import is_xpath
from utils.human_behavior import human_type


def get_locator(page: Page, selector: str) -> Locator:
    return page.locator(f"xpath={selector}") if is_xpath(selector) else page.locator(selector)


async def find_sso_buttons(page: Page, selectors: List[str], provider_name: str = "provider") -> List[str]:
    found: List[str] = []
    # Provider-specific fallbacks (e.g., Google Identity Services / GSI)
    if provider_name.lower() == "google":
        selectors = list(dict.fromkeys(selectors + [
            ".g_id_signin",
            "div[id^='g_id_'][role='button']",
            "[data-ux-mode] div[role='button']:has-text('Google')",
        ]))
    # Probe modals and widgets that might be hidden; click common openers first
    openers = [
        "button:has-text('Log in')",
        "button:has-text('Sign in')",
        "button:has-text('Sign up')",
        "a:has-text('Log in')",
        "a:has-text('Sign in')",
        "a:has-text('Sign up')",
    ]
    for op in openers:
        try:
            loc = page.locator(op)
            if await loc.count() > 0 and await loc.first.is_visible():
                await loc.first.click()
                await page.wait_for_timeout(500)
        except Exception:
            continue
    for sel in selectors:
        try:
            loc = get_locator(page, sel)
            count = await loc.count()
            if count == 0:
                continue
            for i in range(count):
                item = loc.nth(i)
                try:
                    await item.scroll_into_view_if_needed(timeout=1000)
                except Exception:
                    pass
                await page.wait_for_timeout(150)
                if await item.is_enabled() and await item.is_visible():
                    found.append(sel)
                    break
        except Exception:
            continue
    # If nothing found on main page, search iframes (common for GIS buttons)
    if not found:
        for fr in page.frames:
            for sel in selectors:
                try:
                    loc = fr.locator(sel)
                    count = await loc.count()
                    if count == 0:
                        continue
                    for i in range(count):
                        item = loc.nth(i)
                        try:
                            await item.scroll_into_view_if_needed(timeout=1000)
                        except Exception:
                            pass
                        await page.wait_for_timeout(150)
                        if await item.is_enabled() and await item.is_visible():
                            found.append(sel)
                            raise StopIteration
                except StopIteration:
                    break
                except Exception:
                    continue
    if found:
        logger.info(f"Found {len(found)} {provider_name} SSO buttons, using first visible: {found[0]}")
    return found


async def dismiss_cookies(page: Page, reject_selectors: List[str], accept_selectors: List[str]) -> bool:
    # Try reject first
    for sel in reject_selectors + accept_selectors:
        try:
            loc = get_locator(page, sel)
            if await loc.count() > 0 and await loc.first.is_visible():
                await loc.first.click()
                return True
        except Exception:
            continue
    return False


async def fill_form_field(page: Page, selector: str, text: str) -> bool:
    try:
        loc = get_locator(page, selector)
        await loc.click()
        await human_type(loc, text)
        value = await loc.input_value()
        return value.strip() == text.strip()
    except Exception:
        return False


async def smart_submit(page: Page, submit_selector: Optional[str] = None) -> bool:
    """Submit a form using explicit selector or common heuristics.

    Returns True if a click/submit action was attempted.
    """
    # 1) Use provided selector
    try:
        if submit_selector:
            loc = get_locator(page, submit_selector)
            if await loc.count() > 0 and await loc.first.is_enabled():
                await loc.first.click()
                return True
    except Exception:
        pass
    # 2) Common submit elements
    candidates = [
        "button[type='submit']",
        "input[type='submit']",
        "button:has-text('Sign up')",
        "button:has-text('Sign in')",
        "button:has-text('Log in')",
        "button:has-text('Start Learning')",
        "button:has-text('Continue')",
    ]
    for sel in candidates:
        try:
            loc = page.locator(sel)
            if await loc.count() > 0 and await loc.first.is_visible():
                await loc.first.click()
                return True
        except Exception:
            continue
    # 3) Press Enter on active element
    try:
        await page.keyboard.press("Enter")
        return True
    except Exception:
        return False


async def wait_for_navigation(page: Page, timeout_ms: int = 30000) -> None:
    try:
        async with page.expect_navigation(timeout=timeout_ms):
            pass
    except PlaywrightTimeoutError:
        # SPA or no hard navigation; wait for network idle as fallback
        await page.wait_for_load_state("networkidle", timeout=timeout_ms)


async def capture_evidence(page: Page, run_dir: Path, name: str, viewport_only: bool = False) -> Tuple[Path, Path]:
    screenshots_dir = run_dir / "screenshots"
    screenshots_dir.mkdir(parents=True, exist_ok=True)
    shot_path = screenshots_dir / f"{name}.png"
    html_path = screenshots_dir / f"{name}.html"
    try:
        await page.screenshot(path=str(shot_path), full_page=not viewport_only, timeout=8000, animations="disabled")
    except Exception as exc:
        logger.warning(f"Screenshot failed for {name}: {exc}")
    try:
        html = await page.content()
        html_path.write_text(html, encoding="utf-8")
    except Exception as exc:
        logger.warning(f"HTML dump failed for {name}: {exc}")
    return shot_path, html_path


async def capture_step_evidence(page: Page, run_dir: Path, step_prefix: str, viewport_only: bool = False) -> dict:
    shot, html = await capture_evidence(page, run_dir, step_prefix, viewport_only)
    # document.cookie
    cookie_txt_path = run_dir / "screenshots" / f"{step_prefix}_cookies.txt"
    try:
        cookie_text = await page.evaluate("() => document.cookie")
        cookie_txt_path.write_text(cookie_text or "", encoding="utf-8")
    except Exception:
        pass
    return {
        "screenshot": str(shot),
        "html": str(html),
        "cookies": str(cookie_txt_path),
    }


async def save_storage_snapshot(page: Page, label: str, accumulator: dict) -> None:
    cookies = await page.context.cookies()
    local = await page.evaluate("() => Object.fromEntries(Object.entries(localStorage))")
    session = await page.evaluate("() => Object.fromEntries(Object.entries(sessionStorage))")
    accumulator[label] = {
        "cookies": cookies,
        "localStorage": local,
        "sessionStorage": session,
    }


def compare_storage(before: dict, after: dict) -> dict:
    return {
        "cookies_changed": before.get("cookies") != after.get("cookies"),
        "localStorage_changed": before.get("localStorage") != after.get("localStorage"),
        "sessionStorage_changed": before.get("sessionStorage") != after.get("sessionStorage"),
    }


def analyze_storage_changes(before_snapshot: dict, after_snapshot: dict) -> dict:
    """Compare storage snapshots to detect account-linking changes."""
    result = {
        "cookies_added": [],
        "cookies_removed": [],
        "localStorage_changes": {},
        "sessionStorage_changes": {},
    }
    # Cookies
    before_cookies = {(c.get("name"), c.get("domain"), c.get("path")) for c in before_snapshot.get("cookies", [])}
    after_cookies = {(c.get("name"), c.get("domain"), c.get("path")) for c in after_snapshot.get("cookies", [])}
    result["cookies_added"] = list(after_cookies - before_cookies)
    result["cookies_removed"] = list(before_cookies - after_cookies)

    # LocalStorage
    bl = before_snapshot.get("localStorage", {}) or {}
    al = after_snapshot.get("localStorage", {}) or {}
    for k in set(bl.keys()).union(al.keys()):
        if bl.get(k) != al.get(k):
            result["localStorage_changes"][k] = {"before": bl.get(k), "after": al.get(k)}

    # SessionStorage
    bs = before_snapshot.get("sessionStorage", {}) or {}
    as_ = after_snapshot.get("sessionStorage", {}) or {}
    for k in set(bs.keys()).union(as_.keys()):
        if bs.get(k) != as_.get(k):
            result["sessionStorage_changes"][k] = {"before": bs.get(k), "after": as_.get(k)}

    return result


async def extract_account_identifier(page: Page, selector: Optional[str]) -> Optional[str]:
    if not selector:
        return None
    try:
        loc = get_locator(page, selector)
        if await loc.count() == 0:
            return None
        text = await loc.first.inner_text()
        return text.strip()
    except Exception:
        return None


async def with_retries(coro_fn, max_retries: int = 2, base_delay: float = 1.0):
    for attempt in range(max_retries + 1):
        try:
            return await coro_fn()
        except PlaywrightTimeoutError as e:
            if attempt == max_retries:
                raise
        except Exception as e:
            if attempt == max_retries:
                raise
        # Exponential backoff with Â±20% jitter
        delay = base_delay * (2 ** attempt)
        jitter = delay * random.uniform(-0.2, 0.2)
        await asyncio.sleep(max(0.1, delay + jitter))


async def navigate_and_wait(page: Page, url: str, timeout_ms: int = 30000):
    await page.goto(url, wait_until="domcontentloaded")
    try:
        await page.wait_for_load_state("networkidle", timeout=timeout_ms)
    except Exception:
        pass


async def capture_performance_metrics(page: Page) -> dict:
    try:
        nav = await page.evaluate("() => JSON.stringify(performance.getEntriesByType('navigation'))")
        res = await page.evaluate("() => JSON.stringify(performance.getEntriesByType('resource').slice(0,200))")
        return {"navigation": nav, "resources": res}
    except Exception:
        return {}


async def extract_identifier_fallbacks(page: Page) -> Optional[str]:
    try:
        # Common profile/email hints
        candidate_selectors = [
            ".user-email, .profile-email, [data-testid='user-email']",
            "[data-user-email]",
            "meta[name='user:email']",
        ]
        for sel in candidate_selectors:
            loc = page.locator(sel)
            if await loc.count() > 0 and await loc.first.is_visible():
                try:
                    if sel.startswith("meta"):
                        val = await page.evaluate("sel => document.querySelector(sel)?.content || ''", sel)
                        if val:
                            return val.strip()
                    else:
                        txt = await loc.first.inner_text()
                        if txt:
                            return txt.strip()
                except Exception:
                    continue
    except Exception:
        return None
    return None


def to_absolute_url(base_url: str, maybe_relative: str) -> str:
    try:
        if maybe_relative.startswith("http://") or maybe_relative.startswith("https://"):
            return maybe_relative
        return urljoin(base_url.rstrip("/") + "/", maybe_relative)
    except Exception:
        return maybe_relative


async def expect_and_handle_oauth_popup(
    page: Page,
    click_selector: str,
    test_email: Optional[str],
    record_redirects: Optional[list] = None,
    target_domain: Optional[str] = None,
) -> bool:
    """Click an OAuth button and handle both popup and same-tab flows.

    Returns True if the flow was triggered and we likely completed selection/consent.
    """
    try:
        # Prepare listeners for popup and same-tab Google navigation
        popup_task = asyncio.create_task(page.wait_for_event("popup", timeout=15000))
        url_task = asyncio.create_task(page.wait_for_url(r".*(accounts\\.google\\.com|/oauth|/authorize).*", timeout=15000))
        # Trigger on page or in a frame as fallback
        try:
            await page.locator(click_selector).first.click()
        except Exception:
            clicked = False
            for fr in page.frames:
                try:
                    loc = fr.locator(click_selector)
                    if await loc.count() > 0 and await loc.first.is_visible():
                        await loc.first.click()
                        clicked = True
                        break
                except Exception:
                    continue
            if not clicked:
                # give up
                return False
        surface: Optional[Page] = None
        done, pending = await asyncio.wait({popup_task, url_task}, return_when=asyncio.FIRST_COMPLETED)
        for t in pending:
            t.cancel()
        if popup_task in done and not popup_task.cancelled():
            try:
                popup = popup_task.result()
                surface = popup
                try:
                    await popup.wait_for_load_state("domcontentloaded", timeout=15000)
                except Exception:
                    pass
            except Exception:
                surface = None
        if surface is None:
            # Same-tab flow
            surface = page

        # Capture OAuth-related responses
        def _capture(resp):
            try:
                url = resp.url
                if any(key in url for key in ("oauth", "authorize", "token", "callback", "openid")):
                    status_attr = getattr(resp, "status", None)
                    status_val = status_attr() if callable(status_attr) else status_attr
                    entry = {"url": url, "status": status_val}
                    if record_redirects is not None:
                        record_redirects.append(entry)
            except Exception:
                pass
        try:
            surface.on("response", _capture)
        except Exception:
            pass

        # Try selecting the test account if chooser is shown
        try:
            if test_email:
                for sel in [
                    f"[data-email='{test_email}']",
                    f"[data-identifier='{test_email}']",
                    f"div[role='link']:has-text('{test_email}')",
                    f"div[role='button']:has-text('{test_email}')",
                    f"span:has-text('{test_email}')",
                ]:
                    loc = surface.locator(sel)
                    if await loc.count() > 0 and await loc.first.is_visible():
                        logger.info("[oauth] Selecting Google account by exact email match")
                        await loc.first.click()
                        break
            chooser_candidates = [
                "li[data-email]",
                "div[data-email]",
                "div[role='listitem']",
                "div[role='link']",
                "div[role='button'][data-identifier]",
            ]
            visible_tiles: list[Locator] = []
            for cs in chooser_candidates:
                try:
                    loc = surface.locator(cs)
                    count = await loc.count()
                    for i in range(count):
                        item = loc.nth(i)
                        try:
                            if await item.is_visible():
                                txt = ""
                                try:
                                    txt = (await item.inner_text()).strip()
                                except Exception:
                                    pass
                                if "Use another" in txt:
                                    continue
                                visible_tiles.append(item)
                        except Exception:
                            continue
                except Exception:
                    continue
            if visible_tiles:
                chosen = None
                if test_email:
                    for it in visible_tiles:
                        try:
                            if await it.locator(f"text={test_email}").count() > 0:
                                chosen = it
                                break
                        except Exception:
                            continue
                if chosen is None and len(visible_tiles) == 1:
                    chosen = visible_tiles[0]
                if chosen is not None:
                    logger.info("[oauth] Auto-selecting first visible Google account tile")
                    await chosen.click()
        except Exception:
            pass

        # Consent screens (both popup and same-tab)
        for sel in [
            "button:has-text('Allow')",
            "#submit_approve_access",
            "button:has-text('Continue')",
            "button[name='approve']",
        ]:
            try:
                if await surface.locator(sel).count() > 0:
                    await surface.locator(sel).first.click()
                    await surface.wait_for_load_state("networkidle", timeout=20000)
            except Exception:
                continue

        # Wait for return to target domain (if provided)
        try:
            if target_domain:
                await page.wait_for_url(rf".*{target_domain.replace('.', '\\.')}.*", timeout=30000)
        except Exception:
            pass

        # If a popup was used, wait for it to close briefly (non-blocking)
        try:
            if surface is not page:
                await surface.wait_for_event("close", timeout=5000)
        except Exception:
            pass

        return True
    except Exception as e:
        logger.debug(f"OAuth flow handling error: {e}")
        return False



async def attempt_logout(page: Page, domain_cfg: dict) -> bool:
    """Attempt to log out using site-specific or generic selectors.

    Tries opening profile menus, clicking logout entries, or navigating to a configured logout URL.
    Returns True if a logout action was likely performed.
    """
    # 1) Site-configured explicit URL
    logout_url = domain_cfg.get("logout_url")
    if logout_url:
        try:
            logger.info("[logout] Navigating to configured logout_url")
            await navigate_and_wait(page, to_absolute_url(page.url, logout_url), timeout_ms=30000)
            return True
        except Exception:
            pass

    # 2) Open profile menu if present
    profile_openers = domain_cfg.get("profile_menu_selectors", [
        "button[aria-label*='profile' i]",
        "button[aria-label*='account' i]",
        "[data-testid='user-menu']",
        "[data-qa='user-menu']",
        "button:has([class*='avatar'])",
    ])
    for sel in profile_openers:
        try:
            loc = page.locator(sel)
            if await loc.count() > 0 and await loc.first.is_visible():
                await loc.first.click()
                await page.wait_for_timeout(400)
                break
        except Exception:
            continue

    # 3) Click logout entry candidates
    logout_candidates = domain_cfg.get("logout_selectors", [
        "a:has-text('Log out')",
        "button:has-text('Log out')",
        "a:has-text('Sign out')",
        "button:has-text('Sign out')",
        "a[href*='logout']",
        "button[href*='logout']",
    ])
    for sel in logout_candidates:
        try:
            loc = page.locator(sel)
            if await loc.count() > 0 and await loc.first.is_visible():
                await loc.first.click()
                try:
                    await wait_for_navigation(page, timeout_ms=30000)
                except Exception:
                    pass
                return True
        except Exception:
            continue

    return False

